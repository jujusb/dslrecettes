/*
 * generated by Xtext 2.23.0
 */
package cuisine.recipe.validation;

import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import cuisine.recipe.recipe.*;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class RecipeValidator extends AbstractRecipeValidator {
	
	public static final String INGREDIENTS = "ingredient";
	public static final String UTENSIL = "utensil";
	public static final String PREPARATION = "preparation";
	public static final String QUANTITY = "quantity";
	public static final String TEMPERATURE = "temperature";
	public static final String TIME = "time";
	public static final String TOOL = "tool";
	public static final String CHOICES = "choices";
	
	public static final String UST_DUP = "ust-dup";
	public static final String UST_DUP_MSG = "This name is already defined : ";
	public static final String UST_TAG_DUP = "ust-tag-dup";
	public static final String UST_TAG_DUP_MSG = "This tag is already defined : ";

	public static final String TECH_DUP = "tech-dup";
	public static final String TECH_DUP_MSG = "This technique name is already defined : ";
	
	public static final String INVALID_TECH_NAME = "invalidTechName";
	public static final String INVALID_TECH_NAME_MSG = "technique name not define : ";
	
		
	public static final String INVALID_INGR_UT_ATAG = "invalidIngrUstAtag";
	public static final String INVALID_INGR_UT_ATAG_MSG = "this @tag ingredient or utensil is not define : ";
	
	public static final String INVALID_INGR_HTAG = "invalidIngrHtag";
	public static final String INVALID_INGR_HTAG_MSG = "this #tag group of ingredient is not define : ";
	
	public static final String INVALID_CHOICES = "invalidChoices";
	public static final String INVALID_CHOICES_MSG = "This choice $1 is not define. You have to choose between : $2";
	
	public static final String INVALID_CHOICES_SIZE = "invalidChoicesPossibility";
	public static final String INVALID_CHOICES_SIZE_MSG = "This choice $1 is not corresponding to any choices possibilities : $2";
	
	public static final String INVALID_UST_INGR_PREP_NAME = "invalidUstAtag";
	public static final String INVALID_UST_INGR_PREP_NAME_MSG = "this name is not define : ";

	public static final String INVALID_INGR_ATAG_PLACE_NAME = "invalidIngrPlace";
	public static final String INVALID_INGR_ATAG_PLACE_NAME_MSG = "this ingredient @tag cannot be placed here. You can only place : ";	
	public static final String INVALID_UT_ATAG_PLACE_NAME = "invalidUtPlace";
	public static final String INVALID_UT_ATAG_PLACE_NAME_MSG = "this utensil @tag cannot be placed here. You can only place : ";	
	
	public static final String INVALID_INGR_HTAG_PLACE_NAME = "invalidIngrPlace";
	public static final String INVALID_INGR_HTAG_PLACE_NAME_MSG = "this ingredient group cannot be placed here. You can only place : ";
	
	public static final String INVALID_UT_PLACE_NAME = "invalidUtPlace";
	public static final String INVALID_UT_PLACE_NAME_MSG = "this utensil cannot be placed here. You can only place : ";
	public static final String INVALID_INGR_PLACE_NAME = "invalidIngrPlace";
	public static final String INVALID_INGR_PLACE_NAME_MSG = "this ingredient name cannot be placed here. You can only place : ";	
	public static final String INVALID_PREP_PLACE_NAME = "invalidPrepPlace";
	public static final String INVALID_PREP_PLACE_NAME_MSG = "this preparation name cannot be placed here. You can only place : ";	
	public static final String INVALID_QT_PLACE_NAME = "invalidQtPlace";
	public static final String INVALID_QT_PLACE_NAME_MSG = "this quantity cannot be placed here. You can only place : ";
	public static final String INVALID_TEMP_PLACE_NAME = "invalidTempPlace";
	public static final String INVALID_TEMP_PLACE_NAME_MSG = "this temperature cannot be placed here. You can only place : ";	
	public static final String INVALID_TIME_PLACE_NAME = "invalidTImePlace";
	public static final String INVALID_TIME_PLACE_NAME_MSG = "this time cannot be placed here. You can only place : ";

	@Check
	public void checkTechniqueAlreadyPresent(Technique technique) {
		// Getting the recipe
        EObject recipe = EcoreUtil2.getRootContainer(technique);
        // Getting all the instances of technique in the model
        List<Technique> candidates = EcoreUtil2.getAllContentsOfType(recipe, Technique.class);
        if(candidates.stream()
			.anyMatch(v -> v.getName().equals(technique.getName()) && v != technique)) {
				error(TECH_DUP_MSG, RecipePackage.Literals.TECHNIQUE__NAME, TECH_DUP);
			}
	}

	@Check
	public void checkUtensilAlreadyPresent(Utensil utensil) {
		// Getting the recipe
        Recipe recipe = EcoreUtil2.getContainerOfType(utensil, Recipe.class);
        // Getting the list of utensil in the model
        List<Utensil> candidates = recipe.getUtensils().getUten();
        if(candidates.stream()
			.anyMatch(v -> customStringToString(v.getName()).equals(customStringToString(utensil.getName())) && v != utensil)) {
				error(UST_DUP_MSG, RecipePackage.Literals.UTENSIL__NAME, UST_DUP);
			}
	}
	
	@Check
	public void checkUtensilTagAlreadyPresent(Utensil utensil) {
		// Getting the recipe
        Recipe recipe = EcoreUtil2.getContainerOfType(utensil, Recipe.class);
        // Getting all the instances of utensil in the model
        List<Utensil> candidates = recipe.getUtensils().getUten();
        if(candidates.stream()
			.anyMatch(v -> v.getTag().equals(utensil.getTag()) && v != utensil)) {
				error(UST_TAG_DUP_MSG, RecipePackage.Literals.UTENSIL__TAG, UST_TAG_DUP);
			}
	}
	
	@Check
	public void checkInstructionTechniqueExist(Instruction instruction) {
		// Getting the recipe
        EObject recipe = EcoreUtil2.getRootContainer(instruction);
        // Getting all the instances of technique in the model
        List<Technique> candidates = EcoreUtil2.getAllContentsOfType(recipe, Technique.class);
        if(getTechniqueFromName(((Instruction) instruction).getTechnique(), candidates)==null) {
				error(INVALID_TECH_NAME_MSG, RecipePackage.Literals.INSTRUCTION__TECHNIQUE, INVALID_TECH_NAME);
			}
	}

	@Check
	public void checkInstructionParameterCorrect(InstructionParameter instructionParam) {
		Instruction instruction = EcoreUtil2.getContainerOfType(instructionParam, Instruction.class);
		// Getting the root
        EObject root = EcoreUtil2.getRootContainer(instruction);
        // Getting all the instances of technique in the book        
        List<Technique> candidates = EcoreUtil2.getAllContentsOfType(root, Technique.class);
        Technique t =getTechniqueFromName(((Instruction) instruction).getTechnique(), candidates);
        // Getting the recipe
        Recipe recipe = EcoreUtil2.getContainerOfType(instruction, Recipe.class);
        int iTechnique=0;
        Object actual = null;
        int iInstructionParam=0;
        InstructionParameter param;
        InstructionParameter previousParam = null;
        boolean debut=true;
        while(previousParam!=instructionParam && iInstructionParam<instruction.getParameters().size()) {
           	param=instruction.getParameters().get(iInstructionParam);
           	SimpleEntry<Object, Integer> parameter = getActualParameter(t, recipe, iTechnique, actual, param, debut);
           	actual=parameter.getKey();
           	iTechnique= parameter.getValue();
           	previousParam=param;
           	iInstructionParam+=1;
        }
	}

	private SimpleEntry<Object, Integer> getActualParameter(
			Technique t, 
			Recipe recipe, 
			int iTechnique, 
			Object actual,
			InstructionParameter param,
			boolean debut) {
		Choices choice=null;
		Map<Object, Integer> next = getNextPossibilities(t, iTechnique, actual);
		if(param.getAtag()!=null) {
			EObject ingUst = getIngredientOrUstensilFromATag(param.getAtag(), recipe);
			if(ingUst==null) {
				error(INVALID_INGR_UT_ATAG_MSG+param.getAtag(), RecipePackage.Literals.INSTRUCTION_PARAMETER__ATAG, INVALID_INGR_UT_ATAG);
			} else {
				if(ingUst instanceof Ingredient) {
					if(next.keySet().contains(INGREDIENTS)) {
						actual = INGREDIENTS;
					} else {
						String msg =INVALID_INGR_PLACE_NAME_MSG+next.keySet().toString();
						error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__ATAG, INVALID_INGR_PLACE_NAME);
					}
				} else if(ingUst instanceof Utensil) {
					if(next.keySet().contains(UTENSIL)) {
						actual = UTENSIL;
					} else if(next.keySet().contains(TOOL)) {
						actual = UTENSIL;
					} else {
						String msg =INVALID_UT_PLACE_NAME_MSG +next.keySet().toString();
						error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__ATAG, INVALID_UT_PLACE_NAME);
					}
				}
			}
		} else if(param.getHtag()!=null) {
			List<Ingredient> list = getIngredientsFromHTag(param.getHtag(), recipe);
			if(list.size()==0) {
				error(INVALID_INGR_HTAG_MSG+param.getHtag(), RecipePackage.Literals.INSTRUCTION_PARAMETER__HTAG, INVALID_INGR_HTAG);
			} else if(next.keySet().contains(INGREDIENTS)) {
				actual = INGREDIENTS;
			} else {
				String msg = INVALID_INGR_HTAG_PLACE_NAME_MSG + next.keySet().toString();
				error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__HTAG, INVALID_INGR_HTAG_PLACE_NAME);
			}
		} else if(param.getParameter()!=null) {
			Object o = getIngredientOrUstensilOrPreparationFromName(param.getParameter(), recipe);
			List<String> paramsChoice = param.getParameter().getName();
			boolean choiceNotValid=true;
			if(o==null) {
				int i=0;
				Object obj = null;
				while(choiceNotValid && i<next.keySet().size()) {
					obj = next.keySet().toArray()[i];
					if(obj instanceof Choices) {
						choice=(Choices) obj;
						if(paramsChoice.size()==1) {
							String c=paramsChoice.get(0).trim();
		        			if(!(choice.getChoice().contains(c))) {
		        				error(INVALID_CHOICES_MSG.replace("$1", c).replace("$2", choice.getChoice().toString()), RecipePackage.Literals.INSTRUCTION_PARAMETER__PARAMETER, INVALID_CHOICES);
		        			} else {
		        				choiceNotValid=false;
		        			}
						} else {
							if(paramsChoice.size()==choice.getChoices().size()) {
								int j=0;
								for(String c : paramsChoice) {
									if(!((Choice)choice.getChoices().get(j)).getChoice().contains(c.trim())) {
										error(INVALID_CHOICES_MSG.replace("$1", c).replace("$2", ((Choice)choice.getChoices().get(j)).getChoice().toString()), RecipePackage.Literals.INSTRUCTION_PARAMETER__PARAMETER, INVALID_CHOICES);
									}
									j++;
								}
								choiceNotValid=false;
							} else {
								choiceNotValid=true;
							}
						}
					}
					i++;
				}
				if(choice==null) {
					error(INVALID_UST_INGR_PREP_NAME_MSG + customStringToString(param.getParameter()), RecipePackage.Literals.INSTRUCTION_PARAMETER__PARAMETER, INVALID_UST_INGR_PREP_NAME);
				} else if(choiceNotValid) {
					error(INVALID_CHOICES_SIZE_MSG.replace("$1", param.getParameter().toString()).replace("$2", choice.getChoices().toString()), RecipePackage.Literals.INSTRUCTION_PARAMETER__PARAMETER, INVALID_CHOICES_SIZE);
				} else {
					actual= choice;
				}	
			} else {
				if(o instanceof Ingredient) {
					if(next.keySet().contains(INGREDIENTS)) {
						actual = INGREDIENTS;
					} else {
						String msg = INVALID_INGR_PLACE_NAME_MSG +next.keySet().toString();
						error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__PARAMETER, INVALID_INGR_PLACE_NAME);
					}
				} else if(o instanceof Utensil) {
					if(next.keySet().contains(UTENSIL)) {
						actual = UTENSIL;
					} else if(next.keySet().contains(TOOL)) {
						actual = UTENSIL;
					} else {
						String msg = INVALID_UT_PLACE_NAME_MSG +next.keySet().toString();
						error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__PARAMETER, INVALID_UT_PLACE_NAME);
					}
				} else if(o instanceof String) {
					if(next.keySet().contains(PREPARATION)) {
						actual=PREPARATION;
					} else if(next.keySet().contains(INGREDIENTS)) {
						actual=INGREDIENTS;
					} else {
						String msg = INVALID_PREP_PLACE_NAME_MSG +next.keySet().toString();
						error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__PARAMETER, INVALID_PREP_PLACE_NAME);
					}
				}
			}
		} else if(param.getQt()!=null) {
			if(!next.keySet().contains(QUANTITY)) {
				String msg = INVALID_QT_PLACE_NAME_MSG +next.keySet().toString();
				error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__QT, INVALID_QT_PLACE_NAME);
			} else {
				actual = QUANTITY;
			}
		} else if(param.getTemp()!=null) {
			if(!next.keySet().contains(TEMPERATURE)) {
				String msg = INVALID_TEMP_PLACE_NAME_MSG +next.keySet().toString();
				error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__TEMP, INVALID_TEMP_PLACE_NAME);
			} else {
				actual = TEMPERATURE;
			}
		} else if(param.getTime()!=null) {
			if(!next.keySet().contains(TIME)) {
				String msg = INVALID_TIME_PLACE_NAME_MSG +next.keySet().toString();
				error(msg, RecipePackage.Literals.INSTRUCTION_PARAMETER__TIME, INVALID_TIME_PLACE_NAME);
			} else {
				actual = TIME;
			}
		}
		return new SimpleEntry<>(actual, next.get(actual));
	}

	public static Map<Object, Integer> getNextPossibilities(Technique t, int iTechnique, Object actual) {
		int iTech=iTechnique;
		Map<Object, Integer> next = new HashMap<>();
		if(actual!=null) {
			if((List.of(UTENSIL,INGREDIENTS, PREPARATION)).contains(actual)) {
				next.put(actual, iTechnique);		 		
			}
		}
		if(iTech < t.getParam().size()) {
			ParamTechnique tmp = t.getParam().get(iTech);
		 	if(tmp.getObject()!=null) {
		 		iTech++;
		 		if(!next.containsKey(tmp.getObject())) {
		 			next.put(tmp.getObject(), iTech);
		 		}
			} else if(tmp.getObjectFac()!=null) {
        		while(tmp.getObjectFac()!=null && iTech<t.getParam().size()-1) {
        			iTech++;
        			if(!next.containsKey(tmp.getObjectFac())) {
        				next.put(tmp.getObjectFac(),iTech);
        			}
        			if(iTech<t.getParam().size()) {
        				tmp=t.getParam().get(iTech);
        			}
        		}
        		if(tmp.getObjectFac()!=null) {
        			iTech++;
        			if(!next.containsKey(tmp.getObjectFac())) {
        				next.put(tmp.getObjectFac(),iTech);
        			}
    			} else if(tmp.getObject()!=null) {
    				iTech++;
    				if(!next.containsKey(tmp.getObject())) {
    					next.put(tmp.getObject(),iTech);
    				}
        		} else if(tmp.getChoices()!=null) {
        			iTech++;
        			next.put(tmp.getChoices(),iTech);
        		}
        	} else {
        		iTech++;
        		next.put(tmp.getChoices(), iTech);
        	}
		}
		 return next;
	}
	
	public static Technique getTechniqueFromName(String name, List<Technique> techniques) {
		for(Technique t : techniques) {
			if(t.getName().equals(name)) {
				return t;
			}
		}
		return null;
	}
	
	public static String customStringToString(CustomString custom) {
		String string = "";
		for(String s : custom.getName()) {
			string+=s+" ";
		}
		return string;
	}

	
	public static EObject getIngredientOrUstensilFromATag(String atag, Recipe r) {
		for(Ingredient i : ((Recipe)r).getIngredients().getIngr()) {
			if(i.getTag()!=null) {
				if(i.getTag().equals(atag)) {
					return i;
				}
			}
		}
		for(Utensil u : ((Recipe)r).getUtensils().getUten()) {
			if(u.getTag()!=null) {
				if(u.getTag().equals(atag)) {
					return u;
				}
			}
		}
		return null;
	}
	
	public static List<Ingredient> getIngredientsFromHTag(String htag, Recipe r) {
		List<Ingredient> ingredients=new ArrayList<>();
		for(Ingredient i : ((Recipe)r).getIngredients().getIngr()) {
			if(i.getGroup()!=null) {
				if(i.getGroup().equals(htag)) {
					ingredients.add(i);
				}
			}
		}
		return ingredients;
	}
	
	public static Object getIngredientOrUstensilOrPreparationFromName(CustomString s, Recipe r) {
		for(Ingredient i : ((Recipe)r).getIngredients().getIngr()) {
			if(i.getName()!=null) {
				if(customStringToString(i.getName()).equals(customStringToString(s))) {
					return i;
				}
			}
		}
		for(Utensil u : ((Recipe)r).getUtensils().getUten()) {
			if(u.getName()!=null) {
				if(customStringToString(u.getName()).equals(customStringToString(s))) {
					return u;
				}
			}
		}
		
		for(String prep : getPreparationListFromRecipe((Recipe)r)) {// EcoreUtil2.getAllContentsOfType( r, Preparation.class);
			if(prep.equals(customStringToString(s))) {
				return prep;
			}
		}
		return null;
	}
	
	public static List<String> getPreparationListFromRecipe(Recipe r) {
		List<String> preparations = new ArrayList<>();
		for(Instruction i : r.getInstructions().getInst()) {
			if(i.getPreparation()!=null) {
				preparations.add(customStringToString(i.getPreparation()));
			}
		}
		return preparations;
	}
}
